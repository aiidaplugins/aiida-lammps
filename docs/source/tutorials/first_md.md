---
myst:
  substitutions:
    aiida_lammps: '`aiida-lammps`'
    LAMMPS: '[LAMMPS](https://lammps.org)'
    OpenKIM: '[OpenKIM](https://openkim.org/)'
---

(tutorials-md)=

# Molecular dynamics in LAMMPS

The following example will show how one performs a [LAMMPS molecular dynamics](https://docs.lammps.org/run.html) calculation through AiiDA's Python API.
For the purpose of this demonstration, the dynamics of the atoms of bcc iron at room temperature will be calculated.

:::{tip}
The code shown in the snippets below can be {download}`downloaded as a script <include/scripts/run_md_basic.py>`,
The script can be made executable and then run to execute the example calculation.
:::

First import the required classes and functions:

```python
from aiida.engine import run
from aiida.orm import Dict, StructureData, load_code
from aiida_lammps.data.potential import LammpsPotentialData
```

Then, load the code that was setup in AiiDA for `lmp` and get an instance of the [process builder](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/processes/usage.html#process-builder):

```python
# Load the code configured for ``lmp``. Make sure to replace
# this string with the label used in the code setup.
code = load_code('lammps@localhost')
builder = code.get_builder()
```

The process builder can be used to assign and automatically validate the inputs that will be used for the calculation.
One can start by defining and assigning the structure to the builder:

```python
from ase.build import bulk
structure = StructureData(ase=bulk('Fe', 'bcc', 2.87, cubic=True))
builder.structure = structure
```

The crystal structure is generated by making use of the `bulk` method of the [ASE library](https://wiki.fysik.dtu.dk/ase/ase/build/build.html#ase.build.bulk).
The ase structure is then passed to the {class}`~aiida.orm.nodes.data.structure.StructureData`, which generates a node that is stored in AiiDA's provenance graph, and then passed to the builder.

:::{note}
The structure is constructed in such as way as to have a cubic cell with orthogonal axis as {{ LAMMPS }} prefers this kind of setup.
:::

The next step is to define the interatomic potential that will be used for this system.
The interatomic potentials can be found in many repositories such as the ones from [NIST](https://www.ctcms.nist.gov/potentials/) and OpenKIM.
In the following a potential from the OpenKIM repository will be used.

```python
import requests
import io

# Download the potential from the repository and store it as a BytesIO object
_stream = io.BytesIO(requests.get('https://openkim.org/files/MO_546673549085_000/Fe_2.eam.fs', timeout=20).text.encode('utf-8'))

# Set the metadata for the potential
potential_parameters = {
    'species': ['Fe'],
    'atom_style': 'atomic',
    'pair_style': 'eam/fs',
    'units': 'metal',
    'extra_tags': {
        'title': 'EAM potential (LAMMPS cubic hermite tabulation) for Fe developed by Mendelev et al. (2003) v000',
        'content_origin': 'NIST IPRP: https: // www.ctcms.nist.gov/potentials/Fe.html',
        'developer': ['Ronald E. Miller'],
        'publication_year': 2018,
    }
}

# Store the potential in an AiiDA node
potential = LammpsPotentialData.get_or_create(source=_stream,**potential_parameters)

builder.potential = potential
```

The potential is downloaded from the OpenKIM repository making use of the [requests library](https://docs.python-requests.org/en/latest/index.html) and then transformed into a bytes stream via the `BytesIO` class from the [core io library](https://docs.python.org/3/library/io.html).
After that one needs to define the metadata for the potential, this is necessary to be able to make sure that the potential is used only on appropriate systems and that it can be easily tracked.

:::{note}
All the parameters in the `extra_tags` are not necessary to define a potential node, but they will improve the querying and tracking of the potential. For a more detailed explanation see the topic section [](#topics-data-potential).
:::

With the potential data and the metadata dictionary one can then generate a {class}`~aiida_lammps.data.potential.LammpsPotentialData` node which can be assigned to the builder.

Then one needs to define the parameters which control how the input file for the {{ LAMMPS }} calculation is generated.
For a structural minimization the minimal set of parameters is the following:

```python

# Parameters to control the input file generation
parameters = Dict({
    "control": {
        "units": "metal",
        "timestep": 1e-5
    },
    "compute":{
        "pe/atom": [{"type": [{"keyword": " ", "value": " "}], "group": "all"}],
        "ke/atom": [{"type": [{"keyword": " ", "value": " "}], "group": "all"}],
        "stress/atom": [{"type": ["NULL"], "group": "all"}],
        "pressure": [{"type": ["thermo_temp"], "group": "all"}],
    },

    "structure":{"atom_style": "atomic"},
    "thermo":{
        "printing_rate": 100,
        "thermo_printing": {
            "step": True,
            "pe": True,
            "ke": True,
            "press": True,
            "pxx": True,
            "pyy": True,
            "pzz": True,
        }
    },
    "md":{
        "integration": {
            "style": "npt",
            "constraints": {
                "temp": [300, 300, 100],
                "iso": [0.0, 0.0, 1000.0],
            },
        },
        "max_number_steps": 5000,
        "velocity": [{"create": {"temp": 300}, "group": "all"}],
    },
})
builder.parameters = parameters
```
The parameters have several sections which control different behavior of the calculation:

- `control` section handles global parameters for the simulation, such as the units and time step.
- `compute` section specifies which parameters will be calculated and printed to file during the LAMMPS simulation ([see compute command](https://docs.lammps.org/compute.html)).
- `structure`: controls aspects related to the structure handling in {{ LAMMPS }}.
- `thermo`: controls which global thermodynamic information will be calculated and written to file ([see thermo command](https://docs.lammps.org/thermo.html)).
- `md`: controls how the molecular dynamics calculations are performed. Controlling which type of ensemble will be used, eg. [npt](https://docs.lammps.org/fix_nh.html#fix-npt-command), [nvt](https://docs.lammps.org/fix_nh.html#fix-nvt-command), [nve](https://docs.lammps.org/fix_nve.html) as well as initial thermalization parameters such as the [velocities](https://docs.lammps.org/velocity.html) of the particles.

:::{note}
For a detailed explanation of the possible options in the parameters see the [](#topics-data-parameters) topic section.

:::

Lastly one needs to define the computational resources needed to perform the calculation
```python
# Run the calculation on 1 CPU and kill it if it runs longer than 1800 seconds.
# Set ``withmpi`` to ``False`` if ``pw.x`` was compiled without MPI support.
builder.metadata.options = {
    'resources': {
        'num_machines': 1,
    },
    'max_wallclock_seconds': 1800,
    'withmpi': False,
}
```

Now as all the needed parameters have been defined the calculation can bse launched using the process builder:

```python
outputs, node = run.get_node(builder)
```

Once the calculation is finished `run.get_node` will return the outputs produced and the calculation node, `outputs` and `node` respectively.

The `node` is the entry that contains the information pertaining the calculation.
It is possible to check if the calculation finished successfully (processes that return `0` are considered to be successful) by looking at its exit status:

```python
node.exit_status
```

If the result is different from zero it means that a problem was encountered in the calculation. This might indicate that some output is not present, that the calculation failed due to a transitory issue, an input problem, etc.

The `outputs` is a dictionary containing the output nodes produced by the calculation:

```python
print(outputs)
{
    'remote_folder': <RemoteData: uuid: 4d5ffdc5-2935-478a-bbc3-2b5ac5bcd663 (pk: 77519)>,
    'retrieved': <FolderData: uuid: e2dc6535-d954-470d-9ea9-c330b289f0d1 (pk: 77520)>,
    'results': <Dict: uuid: ff724a1f-c24f-4dae-907f-7883a4770c69 (pk: 77521)>,
    'time_dependent_computes': <ArrayData: uuid: d8150b46-8c2c-4a23-b039-7ef2a3e50554 (pk: 77522)>,
    'trajectories': <LammpsTrajectory: uuid: f7af7031-6cd9-4adc-936e-27bdd358210e (pk: 77523)>,
    'structure': <StructureData: uuid: 4bc51630-358d-4f1f-89ed-972bbd37d51e (pk: 77524)>,
}
```

The `results` node is a dictionary that will contain the final result of the calculated thermodynamic variables as well as general information about the calculation status

```python
print(outputs['results'].get_dict())
{
    'final_ke': 0.024456795122703,
    'final_pe': -8.2274854545799,
    'final_pxx': -26539.404872624,
    'final_pyy': -25646.583264533,
    'final_pzz': -25646.563988137,
    'final_step': 5000,
    ...
}
```

The `time_dependent_computes` contains a series of numpy arrays each one representing the values the global variables as a function of time. One can get the names of the arrays by making use of the `.get_arraynames()` method and an individual array can be accesses by making use of `.get_array('array_name')` where `'array_name'` is one of the strings found with the previous command.

The complete output that was written by {{ LAMMPS }} to stdout, can be retrieved as follows:

```python
results['retrieved'].base.repository.get_object_content('aiida_lammps.out')
```
