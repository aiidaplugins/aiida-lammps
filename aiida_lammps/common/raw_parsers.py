"""Set of functions to parse the unformatted files generated by LAMMPS.
"""
# pylint: disable=fixme
import ast
import re
from typing import Union

import numpy as np
import yaml


def parse_logfile(filename: str = None, file_contents: str = None) -> Union[dict, dict]:
    """
    Parse the log.lammps file.

    This will gather the time dependent data stored in the log file and
    stores it as a dictionary. It will also gather single quantities and stores
    them into a different dictionary.

    :param filename: name of the lammps log file, defaults to None
    :type filename: str, optional
    :param file_contents: contents of the lammps log file, defaults to None
    :type file_contents: str, optional
    :return: dictionary with the time dependent data, dictionary with the global data
    :rtype: Union[dict, dict]
    """
    # pylint: disable=too-many-branches, too-many-locals

    if filename is None and file_contents is None:
        return None

    if filename is not None:

        try:
            with open(filename) as handler:
                data = handler.read()
                data = data.split("\n")
        except OSError:
            return None

    if file_contents is not None:
        data = file_contents.split("\n")

    header_line_position = -1
    header_line = ""
    _data = []
    end_found = False
    parsed_data = {}
    global_parsed_data = {}

    perf_regex = re.compile(r".*Performance\:.*\,\s+([0-9\.]*)\stimesteps\/s.*")
    performance_match = perf_regex.search(file_contents or "")
    if performance_match:
        global_parsed_data["steps_per_second"] = float(performance_match.group(1))

    for index, line in enumerate(data):
        line = line.strip()
        if "binsize" in line:
            global_parsed_data["binsize"] = ast.literal_eval(
                line.split()[2].replace(",", "")
            )
            global_parsed_data["bins"] = [
                ast.literal_eval(entry) for entry in line.split()[5:]
            ]
        if "ghost atom cutoff" in line:
            global_parsed_data["ghost_atom_cutoff"] = ast.literal_eval(line.split()[-1])
        if "master list distance cutoff" in line:
            global_parsed_data["master_list_distance_cutoff"] = ast.literal_eval(
                line.split()[-1]
            )
        if "max neighbors/atom" in line:
            global_parsed_data["max_neighbors_atom"] = ast.literal_eval(
                line.split()[2].replace(",", "")
            )
        if "units" in line:
            global_parsed_data["units_style"] = line.split()[1]
        if "Total wall time:" in line:
            global_parsed_data["total_wall_time"] = line.split()[-1]
        if "bin:" in line:
            global_parsed_data["bin"] = line.split()[-1]
        if line.startswith("Step"):
            header_line_position = index
            header_line = [
                re.sub("[^a-zA-Z0-9_]", "__", entry) for entry in line.split()
            ]
        if header_line_position > 0 and index != header_line_position and not end_found:
            if not line.split()[0].replace(".", "", 1).isdigit():
                end_found = True
        if header_line_position > 0 and index != header_line_position and not end_found:
            _data.append([ast.literal_eval(entry) for entry in line.split()])
    _data = np.asarray(_data)
    for index, entry in enumerate(header_line):
        parsed_data[entry] = _data[:, index].tolist()
    return {"time_dependent": parsed_data, "global": global_parsed_data}


def parse_final_data(filename: str = None, file_contents: str = None) -> dict:
    """
    Read the yaml file with the global final data.

    The final iteration for each of computed variables is sotred into a yaml
    file which is then read and stored as a dictionary.

    :param filename: name of the yaml file where the variables are stored,
        defaults to None
    :type filename: str, optional
    :param file_contents: contents of the yaml file where the variables are stored,
        defaults to None
    :type file_contents: str, optional
    :return: dictionary with the final compute variables
    :rtype: dict
    """

    if filename is None and file_contents is None:
        return None
    if filename is not None:
        try:
            with open(filename) as handle:
                data = yaml.load(handle, Loader=yaml.Loader)
        except OSError:
            data = None
    if file_contents is not None:
        data = yaml.load(file_contents, Loader=yaml.Loader)
    return data


def read_log_file(logdata_txt, compute_stress=False):
    """Read the log.lammps file."""
    # pylint: disable= too-many-locals, too-many-branches
    data = logdata_txt.splitlines()

    if not data:
        raise OSError("The logfile is empty")

    perf_regex = re.compile(
        r"Performance\:\s(.+)\sns\/day,\s(.+)\shours\/ns\,\s(.+)\stimesteps\/s\s*"
    )

    data_dict = {}
    cell_params = None
    stress_params = None
    found_end = False
    for _, line in enumerate(data):
        line = line.strip()
        if "END_OF_COMP" in line:
            found_end = True
        elif "Total wall time:" in line:
            data_dict["total_wall_time"] = line.split()[-1]
        # These are handled in LAMMPSBaseParser.add_warnings_and_errors
        # if line.strip().startswith("WARNING"):
        #     data_dict.setdefault("warnings", []).append(line.strip())
        # if line.strip().startswith("ERROR"):
        #     data_dict.setdefault("errors", []).append(line.strip())
        elif perf_regex.match(line):
            _, _, step_sec = perf_regex.match(line).groups()
            data_dict.setdefault("steps_per_second", []).append(float(step_sec))
        elif "units" in line:
            data_dict["units_style"] = line.split()[1]
        elif line.startswith("final_energy:"):
            data_dict["energy"] = float(line.split()[1])
        elif line.startswith("final_variable:"):
            if "final_variables" not in data_dict:
                data_dict["final_variables"] = {}
            data_dict["final_variables"][line.split()[1]] = float(line.split()[3])

        elif line.startswith("final_cell:"):
            cell_params = [float(v) for v in line.split()[1:10]]
        elif line.startswith("final_stress:"):
            stress_params = [float(v) for v in line.split()[1:7]]

    if not compute_stress:
        return {"data": data_dict, "found_end": found_end}

    if cell_params is None:
        raise OSError("'final_cell' could not be found")
    if stress_params is None:
        raise OSError("'final_stress' could not be found")

    xlo, xhi, box_xy, ylo, yhi, box_xz, zlo, zhi, box_yz = cell_params
    super_cell = np.array(
        [
            [xhi - xlo, box_xy, box_xz],
            [0, yhi - ylo, box_yz],
            [0, 0, zhi - zlo],
        ]
    )
    cell = super_cell.T
    if np.linalg.det(cell) < 0:
        cell = -1.0 * cell
    volume = np.linalg.det(cell)

    box_xx, box_yy, box_zz, box_xy, box_xz, box_yz = stress_params
    stress = np.array(
        [
            [box_xx, box_xy, box_xz],
            [box_xy, box_yy, box_yz],
            [box_xz, box_yz, box_zz],
        ],
        dtype=float,
    )
    stress = -stress / volume  # to get stress in units of pressure

    return {"data": data_dict, "cell": cell, "stress": stress, "found_end": found_end}


def get_units_dict(style, quantities, suffix="_units"):
    """Return a mapping of the unit name to the units, for a particular style.

    :param style: the unit style set in the lammps input
    :type style: str
    :param quantities: the quantities to get units for
    :type quantities: list of str
    :rtype: dict

    """
    units_dict = {
        "real": {
            "mass": "grams/mole",
            "distance": "Angstroms",
            "time": "femtoseconds",
            "energy": "Kcal/mole",
            "velocity": "Angstroms/femtosecond",
            "force": "Kcal/mole-Angstrom",
            "torque": "Kcal/mole",
            "temperature": "Kelvin",
            "pressure": "atmospheres",
            "dynamic_viscosity": "Poise",
            "charge": "e",  # multiple of electron charge (1.0 is a proton)
            "dipole": "charge*Angstroms",
            "electric field": "volts/Angstrom",
            "density": "gram/cm^dim",
        },
        "metal": {
            "mass": "grams/mole",
            "distance": "Angstroms",
            "time": "picoseconds",
            "energy": "eV",
            "velocity": "Angstroms/picosecond",
            "force": "eV/Angstrom",
            "torque": "eV",
            "temperature": "Kelvin",
            "pressure": "bars",
            "dynamic_viscosity": "Poise",
            "charge": "e",  # multiple of electron charge (1.0 is a proton)
            "dipole": "charge*Angstroms",
            "electric field": "volts/Angstrom",
            "density": "gram/cm^dim",
        },
        "si": {
            "mass": "kilograms",
            "distance": "meters",
            "time": "seconds",
            "energy": "Joules",
            "velocity": "meters/second",
            "force": "Newtons",
            "torque": "Newton-meters",
            "temperature": "Kelvin",
            "pressure": "Pascals",
            "dynamic_viscosity": "Pascal*second",
            "charge": "Coulombs",  # (1.6021765e-19 is a proton)
            "dipole": "Coulombs*meters",
            "electric field": "volts/meter",
            "density": "kilograms/meter^dim",
        },
        "cgs": {
            "mass": "grams",
            "distance": "centimeters",
            "time": "seconds",
            "energy": "ergs",
            "velocity": "centimeters/second",
            "force": "dynes",
            "torque": "dyne-centimeters",
            "temperature": "Kelvin",
            "pressure": "dyne/cm^2",  # or barye': '1.0e-6 bars
            "dynamic_viscosity": "Poise",
            "charge": "statcoulombs",  # or esu (4.8032044e-10 is a proton)
            "dipole": "statcoul-cm",  #: '10^18 debye
            "electric_field": "statvolt/cm",  # or dyne/esu
            "density": "grams/cm^dim",
        },
        "electron": {
            "mass": "amu",
            "distance": "Bohr",
            "time": "femtoseconds",
            "energy": "Hartrees",
            "velocity": "Bohr/atu",  # [1.03275e-15 seconds]
            "force": "Hartrees/Bohr",
            "temperature": "Kelvin",
            "pressure": "Pascals",
            "charge": "e",  # multiple of electron charge (1.0 is a proton)
            "dipole_moment": "Debye",
            "electric_field": "volts/cm",
        },
        "micro": {
            "mass": "picograms",
            "distance": "micrometers",
            "time": "microseconds",
            "energy": "picogram-micrometer^2/microsecond^2",
            "velocity": "micrometers/microsecond",
            "force": "picogram-micrometer/microsecond^2",
            "torque": "picogram-micrometer^2/microsecond^2",
            "temperature": "Kelvin",
            "pressure": "picogram/(micrometer-microsecond^2)",
            "dynamic_viscosity": "picogram/(micrometer-microsecond)",
            "charge": "picocoulombs",  # (1.6021765e-7 is a proton)
            "dipole": "picocoulomb-micrometer",
            "electric field": "volt/micrometer",
            "density": "picograms/micrometer^dim",
        },
        "nano": {
            "mass": "attograms",
            "distance": "nanometers",
            "time": "nanoseconds",
            "energy": "attogram-nanometer^2/nanosecond^2",
            "velocity": "nanometers/nanosecond",
            "force": "attogram-nanometer/nanosecond^2",
            "torque": "attogram-nanometer^2/nanosecond^2",
            "temperature": "Kelvin",
            "pressure": "attogram/(nanometer-nanosecond^2)",
            "dynamic_viscosity": "attogram/(nanometer-nanosecond)",
            "charge": "e",  # multiple of electron charge (1.0 is a proton)
            "dipole": "charge-nanometer",
            "electric_field": "volt/nanometer",
            "density": "attograms/nanometer^dim",
        },
    }
    out_dict = {}
    for quantity in quantities:
        out_dict[quantity + suffix] = units_dict[style][quantity]
    return out_dict


def convert_units(value, style, unit_type, out_units):
    """Convert the units of the system from one set to another.

    :param value: value to be converted
    :type value: float
    :param style: LAMMPS unit style name
    :type style: str
    :param unit_type: what kind of unit is being converted
    :type unit_type: str
    :param out_units: what kind of units one wants to have after conversion
    :type out_units: str
    :raises NotImplementedError: if the type of unit to be converted is not "time"
    :return: converted unit to the new unit type
    :rtype: float
    """
    conversion = {
        "seconds": 1,
        "milliseconds": 1e-3,
        "microseconds": 1e-6,
        "nanoseconds": 1e-9,
        "picoseconds": 1e-12,
        "femtoseconds": 1e-15,
    }
    if unit_type != "time" or out_units not in conversion:
        # TODO use https://pint.readthedocs.io
        raise NotImplementedError
    in_units = get_units_dict(style, [unit_type], "")[unit_type]
    return value * conversion[in_units] * (1.0 / conversion[out_units])
